<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title> Page 3 </title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <h1>Calculating...</h1>
  <div id="displayQuestion"></div>
   
  
  <canvas id="glCanvas" width="300" height="300"></canvas>
   
   <button onclick="location.href='page4.html'">Your Fortune Awaits</button>

  <script>
document.getElementById("displayQuestion").innerText = 
  "You asked: " + localStorage.getItem("fortuneQuestion");

/* Additional skill #3: WebGL 3D spinning glowy cube */
const canvas = document.getElementById("glCanvas");


const gl = canvas.getContext("webgl", { alpha: true });
if (!gl) { alert("WebGL not supported"); throw "WebGL not supported"; }

/* Adds lighting */
const vsSource = `
  attribute vec3 position;
  attribute vec3 normal;
  uniform mat4 uMatrix;
  varying vec3 vNormal;
  void main(void) {
    gl_Position = uMatrix * vec4(position, 1.0);
    vNormal = normal;
  }
`;

/* Glowing crystal colors */
const fsSource = `
  precision mediump float;
  varying vec3 vNormal;
  void main(void) {
    vec3 lightDir = normalize(vec3(0.3, 0.7, 1.0));
    float light = dot(normalize(vNormal), lightDir) * 0.5 + 0.5;
    vec3 color = vec3(0.6, 0.4, 1.0) * light + vec3(0.2, 0.1, 0.4);
    gl_FragColor = vec4(color, 0.7);  // translucent
  }
`;

function compileShader(src, type) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    console.error(gl.getShaderInfoLog(shader));
  return shader;
}

const vs = compileShader(vsSource, gl.VERTEX_SHADER);
const fs = compileShader(fsSource, gl.FRAGMENT_SHADER);
const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);
gl.useProgram(program);

/* Cube size */
const vertices = new Float32Array([
  // X, Y, Z,   NX, NY, NZ
  -1,-1,-1,  0,0,-1,
   1,-1,-1,  0,0,-1,
   1, 1,-1,  0,0,-1,
  -1, 1,-1,  0,0,-1,

  -1,-1, 1,  0,0,1,
   1,-1, 1,  0,0,1,
   1, 1, 1,  0,0,1,
  -1, 1, 1,  0,0,1,

  -1,-1,-1, -1,0,0,
  -1, 1,-1, -1,0,0,
  -1, 1, 1, -1,0,0,
  -1,-1, 1, -1,0,0,

   1,-1,-1, 1,0,0,
   1, 1,-1, 1,0,0,
   1, 1, 1, 1,0,0,
   1,-1, 1, 1,0,0,

  -1,-1,-1, 0,-1,0,
  -1,-1, 1, 0,-1,0,
   1,-1, 1, 0,-1,0,
   1,-1,-1, 0,-1,0,

  -1, 1,-1, 0,1,0,
  -1, 1, 1, 0,1,0,
   1, 1, 1, 0,1,0,
   1, 1,-1, 0,1,0
]);

const indices = new Uint16Array([
  0,1,2, 2,3,0,       // back
  4,5,6, 6,7,4,       // front
  8,9,10, 10,11,8,    // left
  12,13,14, 14,15,12, // right
  16,17,18, 18,19,16, // bottom
  20,21,22, 22,23,20  // top
]);

const vertexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
const indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

const posLoc = gl.getAttribLocation(program, "position");
const normLoc = gl.getAttribLocation(program, "normal");
gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 24, 0);
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(normLoc, 3, gl.FLOAT, false, 24, 12);
gl.enableVertexAttribArray(normLoc);

const matrixLoc = gl.getUniformLocation(program, "uMatrix");

function identity() {
  return new Float32Array([
    1,0,0,0,
    0,1,0,0,
    0,0,1,0,
    0,0,0,1
  ]);
}
function multiply(a, b) {
  const out = new Float32Array(16);
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      out[j * 4 + i] =
        a[i] * b[j * 4] +
        a[4 + i] * b[j * 4 + 1] +
        a[8 + i] * b[j * 4 + 2] +
        a[12 + i] * b[j * 4 + 3];
    }
  }
  return out;
}
function perspective(fov, aspect, near, far) {
  const f = 1.0 / Math.tan(fov / 2);
  const nf = 1 / (near - far);
  const out = identity();
  out[0] = f / aspect;
  out[5] = f;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[14] = (2 * far * near) * nf;
  out[15] = 0;
  return out;
}
function translation(tx, ty, tz) {
  const out = identity();
  out[12] = tx;
  out[13] = ty;
  out[14] = tz;
  return out;
}
function rotationY(angle) {
  const c = Math.cos(angle);
  const s = Math.sin(angle);
  return new Float32Array([
    c, 0, s, 0,
    0, 1, 0, 0,
   -s, 0, c, 0,
    0, 0, 0, 1
  ]);
}
function rotationX(angle) {
  const c = Math.cos(angle);
  const s = Math.sin(angle);
  return new Float32Array([
    1, 0, 0, 0,
    0, c, -s, 0,
    0, s, c, 0,
    0, 0, 0, 1
  ]);
}

let angle = 0;
function draw() {
  angle += 0.02;
  const proj = perspective(Math.PI / 4, canvas.width / canvas.height, 0.1, 100);
  const rotY = rotationY(angle);
  const rotX = rotationX(angle * 0.5);
  const trans = translation(0, 0, -6);
  const matrix = multiply(proj, multiply(trans, multiply(rotY, rotX)));

  gl.uniformMatrix4fv(matrixLoc, false, matrix);
  gl.enable(gl.DEPTH_TEST);
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  gl.clearColor(0.05, 0.02, 0.1, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
  requestAnimationFrame(draw);
}

draw();
</script>


</body>
</html>